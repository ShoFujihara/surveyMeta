% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract.R
\name{extract_metadata}
\alias{extract_metadata}
\title{Extract metadata from a survey document}
\usage{
extract_metadata(
  file_path,
  api_key = NULL,
  model = "claude-sonnet-4-5-20250929",
  max_tokens = 8192L,
  pdf_mode = c("hybrid", "text", "vision"),
  verbose = TRUE
)
}
\arguments{
\item{file_path}{Character. Path to the survey document (PDF or text).
Can also be a character vector of multiple file paths for the same survey
(e.g., questionnaire + report).}

\item{api_key}{Character. API key. If NULL (default), auto-detected from
environment variables: \code{ANTHROPIC_API_KEY} for Claude models,
\code{GEMINI_API_KEY} for Gemini models.}

\item{model}{Character. Model to use. Claude models (e.g.,
"claude-sonnet-4-5-20250929") or Gemini models (e.g., "gemini-2.0-flash").}

\item{max_tokens}{Integer. Maximum tokens in the response.}

\item{pdf_mode}{Character. How to read PDF files:
\describe{
\item{"text"}{Extract text using pdftools (with layout-aware fallback).
Most cost-efficient.}
\item{"vision"}{Send PDFs directly to the API's vision capability.
Best for scanned/image PDFs.}
\item{"hybrid"}{(Default) Assess PDF quality first; use text extraction
for good/fair quality, vision for poor quality PDFs.}
}}

\item{verbose}{Logical. Print progress messages.}
}
\value{
A named list of extracted metadata fields.
}
\description{
Reads a survey document (questionnaire, report, etc.), sends it to
Claude or Gemini API with controlled vocabulary context, and returns
structured metadata conforming to the JDCat/DDI schema.
}
\examples{
\dontrun{
# Claude (default)
result <- extract_metadata("survey_report.pdf")

# Gemini (free tier available)
result <- extract_metadata("survey_report.pdf", model = "gemini-2.0-flash")

# Multiple documents for one survey
result <- extract_metadata(c("questionnaire.pdf", "report.pdf"))

# Force vision mode for scanned PDFs
result <- extract_metadata("scanned_doc.pdf", pdf_mode = "vision")

# Export to CSV
export_metadata(result, "metadata.csv")
}

}
